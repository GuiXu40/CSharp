# :page_with_curl: 继承 #
## :bookmark_tabs:1.1继承 ##
面向对象的三个最重要的概念是继承，封装和多态性。当类型某成员声明为private时，他们就不能从外部访问。他们封装在类型中本章重
点就在继承和多态。
***
## :bookmark_tabs:1.2继承的类型 ##
下面先介绍一些面向对象的术语：<br>
* 单重继承：表示一个类可以派生自一个基类。C#就采用这继承。<br>
* 多种继承：多重继承允许一个类派生自多个类。C#不支持类的多重继承，但允许接口的多重继承。在C++支持所谓的“多重继承”，会给代
码增加复杂性，还会带来一些开销<br>
* 多层继承：多重继承允许继承有更大的层次结构，类B派生自类A，类C又派生自类B。其中类B也称为中间基类，C#支持它，也很常用。<br>
* 接口继承：定义了接口的继承。这里允许多重继承。接口和接口继承参见本章后面的“接口”<br>
***
## :bookmark_tabs:1.3实现继承 ##
如果声明派生自另一个类的一个类，就可以使用下面的语法：

```C#
    class 派生类名 ： 继承类名
    {
        //成员数据等...
    }
```
如果类也派生自接口，则用逗号分隔列表中的基类和接口：

```C#
    public class 派生类名 ： 继承类名,接口1,接口2
    {
        //成员数据等...
    }
```
对于结构只能如下（只能用于接口继承）：

```C#
    public struct 类名 : 接口1,接口2
    {
        //成员数据等...
    }
```
如果在定义中没有指定基类，C#编译器就假定System.Objest是基类。因此，派生自Object类，与不定义基类的效果是相同的。下面的
例子定义基类Shape。无论是什么形状，形状都有一个共同点：位置和长宽，Shape类定义了只读属性Position和Size，可以从一个类
中
调用原基类：

```C#
    class Position
    {
        public int X{get;set;}
        public int Y{get;set;}
    }
    class Size
    {
        public int Width{get;set;}
        public int Height{get;set;}

    }
    class Shape
    {
        public Position Position{get;} = new Position();
        public Size Size{get;} = new Size();
    }
```
我们使用自动属性初始化器来初始化:

```C#
    Shape s1 = new Shape();
    s1.Size.Width = 100;
    s1.Size.Height = 200;
    s1.Position.X = 0;
    s1.Position.Y = 0;
    Console.WriteLine("面积为："+s1.Size.Width*s1.Size.Height);
    Console.WriteLine("坐标点为：("+s1.Position.X+","+s1.Position.Y+")");
```
### :page_facing_up:1.3.1虚方法 ###
把一个基类方法声明为virtual，就可以在任何派生类中重写该方法,重写该方法使用关键字override，这样就可以在任何派生类中
重写该函数：

```C#
    class NewShape : Shape
    {
        public override void Draw()
        {
            Console.WriteLine($"形状的坐标点: ({Position.X},{Position.Y}) 面积为:{Size.Width*Size.Height}");
        }
    }
```
也可以把属性声明为virtual。对于虚属性或重写属性，语法与非虚属性相同，但要在定义中添加关键字virtual，其语法如下所示：
    public virtual Size Size{get; set;}
但主要用于方法，当然两者的使用规则也一样,成员字段和静态函数都不能声明为virtual,因为这个概念只对类中的实例函数成员有意义。

### :page_facing_up:1.3.2多态性 ###
使用多态性，可以动态地调用的方法，而不是在编译期间定义，在下面的例子中，DrawShape()方法接受一个Shape参数，并调用Shape的方法Draw:

```C#
        public static void DrawShape(Shape s)
        {
            s.Draw();
        }
```
在上面派生类NewShape中因为派生于基类Shape，所以DrawShape也可以调用NewShape的类型：

```C#
    var s2 = new NewShape();
    DrawShape(s2);
```
### :page_facing_up:1.3.3隐藏方法 ###
如果签名相同的方法在基类和派生中都进行了声明，但方法都没有分别声明为virtual 和 override,派生类方法就会隐藏基类方法。需要使用new关键字定义方法：
    
    new public void 重名方法
    {
        //.......
    }
不使用new关键字，也可以重命名方法，或者，如果基类的方法声明为virtual，且用作相同的目的，就重写它。然而其他方法调用了此方法，简单的重命名会破坏其他代码。
### :page_facing_up:1.3.4调用方法的基类版本 ###
C#有一种特殊的语法用于从派生类中调用方法的基类版本:base.<MethodName>().例如派生类Shape声明了display()方法，想要在派生类NewShape调用它,可以使用基类实现代码:

```C#
    class Shape
    {
        public virtual void display()
        {
            Console.WriteLine("演示");
        }
    }
```
在NewShape中可以用base调用：

```C#
    class NewShape : Shape
    {
        public override void Draw()
        {
            Console.WriteLine($"形状的坐标点: ({Position.X},{Position.Y}) 面积为:{Size.Width*Size.Height}");
            base.display();
        }
    }
```
### :page_facing_up:1.3.5抽象类和抽象方法 ###
C#允许把类和方法声明为abstract。抽象类不能实例化，而抽象方法不能直接实现，必须在非抽象的派生类中重写，显然，抽象方法本身也是虚拟的。如果类包含抽象，则该类也是抽象的，也必须声明为抽象的。
下面把Shape类改为抽象类。因为其他类需要派生自这个类，新方法Resize声明为抽象，因此它不能有在Shape类中的任何实现代码：

```C#
    public abstract class Shape
    {
        public int Width;
        public int Height;
        public abstract void Resize(int width,int height);
       //不能有实现的方法,因为该方法为抽象类
    }
```
从抽象基类中派生类型时，需要实现所有抽象成员，否者会编译错误：

```C#
    public class Ellipse : Shape
    {
        public override void Resize(int width, int height)
        {
            Width = width;
            Height = height;
            Console.WriteLine(Width + " " + Height);
        }
    }
```
可以声明Shape的一个变量，但是不能实例化它，但是可以实例化Ellipse,并将其分配给Shape变量

```C#
     var s1 = new Ellipse();
     s1.Resize(4,5);
```
### :page_facing_up:1.3.6密封类和密封方法 ###
如果不创建派生自某个自定义类的类，该自定义类就应该密封，给类添加sealed关键字，就不允许创建该类的子类。密封一个方法，表示不能重写该方法。

```C#
    sealed public class Shape
    {
        //成员数据......
    }
    
    public class Ellipse : Shape //该类为密封型,不允许继承，编译器报错
    { 
        //成员数据......
    }
```
如果是方法：

```C#
    public class Shape
    {
        public int Width;
        public int Height;
        public virtual void Method()
        {
                Console.WriteLine("Hello World");
        }
    }
    public class Ellipse : Shape
    { 
        public  sealed override void Method()
        {
                Console.WriteLine("Hello World");
        }       
    }
    public class NewType : Ellipse
    { 
        public  override void Method()//上一级声明sealed封装，该方法继承终止，编译错误
        {
                Console.WriteLine("Hello World");
        }       
    }
```
从上面看得出,最原始的类的该方法可以派生一次，不能在基类方法声明为密封方法，且基类方法必须为重写的属性，所以这种方法终止继承的方法比较复杂，如果不希望这个方法重写，在一开始就不要把它声明为virtual.<br>
### :page_facing_up:1.3.7派生类的构造函数###

#### 还在不停的更新中......如有问题或者错误可以联系作者, Email：724119519@qq.com :bowtie::bowtie::bowtie: ####
#### 最近更新时间：2018.9.4 21:21 ####
