# :file_folder:类
:point_right:<a href="#one" >字段<a>
## :book:1.1字段
<a id="one">字段即为类所拥有的数据,不同的数据要区分数据类型如下:<a><br>
先声明一个类
```C#
    public class Student
    {
        public int StuID;
        public string Name;
        public string Sex;
    }
```
实例化对象：

    var Stu = new Student();
添加数据：

    Stu.StuID = 2017110329;
    Stu.Name = "LMC";
    Stu.Sex = "男";
public为公共字段,所以才能直接采用.运算符直接取字段赋值,对于字段最好用私有字段private,这样就不能直接给字段直接赋值,而需要通过方法来赋值来达到保护数据的形式.
***
## :book:1.2属性
属性的概念是：它是一个方法或一对方法,在客户端看来,它就是一个字段.
```C#
    class Student
    {
        //私有字段,外界无法访问.
        private string Name;
        
        //用一个公共字段来间接访问
        public string _Name
        {
            //get表示可以访问
            get{return Name;}
            
            //set表示可以修改
            set{Name = value;}
        }
    }
```
上面get能够读取Name字段,set能够接受参数赋值给Name,实质上就是设置了一个公有的字段来代替了私有字段.<br><br>
**:memo:自动实现属性：**<br>
set,get访问器中如果没有任何逻辑,就可以使用自动属性,即get可以访问,set可以修改,如像下面这样实现1.2中的_Name那样的实现功：

    public string _Name{get;set;}
这样就不用再写return Name和Name = value这样的表达式.若一开始想给某个字段初始化一个默认值可以如下

    public string Sex{get;set;} = "男";
这样的每个实例化对象若字段Sex不加以修改,则会全部默认为男.<br><br>
**:memo:属性的访问修饰符**<br>
C#允许给属性的get,set访问器设置访问修饰符,所以有共有的get,和私有的或保护的set访问器.
    
    public string Name
    {
        get;
        private set;
    }
上面set为私有访问,即不能直接给这个赋值如下形式:

    stu.Name = "Lmc";
这样会报错,因为set的属性是私有.如想赋值可以采用方法来达到目的再加上如下方法：

        public void setName(string name)
        {
            Name = name;
        }
再引用此方法即如下:

    stu.setName("LMC");
这样就给Name字段赋值了.<br><br>
当然访问器也可以只写一个,如果有set,就必须有get访问器.因为只能有了可读属性get,才有可写set属性.所以有些字段可以只有一个可读的get访问器.

        public int StuID
        {
            get;
        }=2017110329;
对于这种的形式就说明字段StuID只能为默认值,无法修改，包括方法也不能对其进行修改,它规定这个字段只能为可读属性.这种方式可以用于固定的数据,并且不想改变
它的值的重要数据.
***
## :book:1.3方法
**:memo:方法声明**<br>

    [修饰语] 返回类型 方法名(参数)
    {
        实现方法步骤......
    }
其实方法与C语言以及C++的函数一样,只是C#术语区分函数和方法.在C#术语中,与特定类相关的函数叫方法.所以方法一般都要来处理类中的字段数据.下面表示显示数据的方法
```C#
    public void Show()
    {
        Console.Write(Name);
        Console.Write(StuID);
        Console.Write(Sex);
    }
```
public 为修饰符表示公有函数可以使用,void 表示无返回类型,本方法无参数,像上面setName方法可以提供一个参数来修改值.<br><br>
**:memo:表达式方法**<br>
除了这种原始的写法,C#6还为方法定义了一种简单的语法,使用运算符 => 来表示方法左边命名与右边步骤,如上面Show()可以改成下面形式：

    public void show() => Console.WriteLine(Name+'\n'+StuID+'\n'+Sex);
对于有返回类型的方法不需要写return,方法直接默认返回如下所示:
```C#
    public class MyMath
    {
        public int num = 10;
        
        //不需要return 关键字
        public int GetSquare() => num*num;
        public int Add10(int x) => x+10;
        public void Show() => Console.WriteLine(num*num);
    }
```
**:memo:方法调用**<br>
对于方法调用上面也有,使用像C++一样的形式用圆点运算符访问.

    int a,b;
    //实例化对象
    var Num = new MyMath();
    //有返回值的可以赋值参数
    a = Num.GetSquare();
    b = Num.Add10(5);
    //没有参数直接引用
    Num.Show();
**:memo:方法的重载**<br>
C#支持方法重载,只需要参数个数不同或者类型不同即可：
    
    class Myclass
    {
        //参数类型不同
        public void show(int a)
        {
            Console.WriteLine("this is a Number:"+a);
        }
        public void show(string a)
        {
            Console.WriteLine("this is a String:"+a);
        }
    }
对于上面这种形式依据参数类型不同编译器会调用不同的方法,你给的参数如果为int型,就会调用 Console.WriteLine("this is a Number:"+a);
并显示出这个数,如果为字符串则就为下面的方式打出字符串,这种重载就可以满足方法对每种参数类型的支持,在后面我们会用到泛型来达到一个方法可以满足任意不同的参数,从而不必用到重载.另外一种重载方式就是参数个数不同：

    class Myclass
    {
        //参数个数不同
        public void show()
        {
            Console.WriteLine("没有任何参数");
        }
        public void show(int a)
        {
            Console.WriteLine("有一个参数a："+a);
        }
        public void show(int a,int b)
        {
            Console.WriteLine("有两个参数a,b"+" a:"+a+" b:"+b);
        }
    }
这样就可以根据参数个数来达到重载,编译器会通过你提供的参数就行匹配不同的方法.这就是两种重载的基本方式,当然也可以用这两种的方式组合,即参数类型和个数都不同的形式,这里就不写例子了.总之只要参数不一样,就可以提供重载方法.<br><br>
**:memo:可选参数**<br>
参数也可以是可选的,必须为可选参数提供默认值.

    public void Add(int a,int b = 5)
    {
        Console.WriteLine(a+b);
    }
如果传入参数只有1个就会被传入a,b为默认值5,表示可加入参数,不加入参数b就为a+5,加入参数就为a+b.如下：

    Add(4)//表示4+5
    Add(4,6)//表示4+6
当然也可以定义多个参数,有默认值的就代表可选参数,从左到右一直赋值,如下：
    
    Add(int a,int b = 1,int c = 2, int d = 3)
    {
        Console.WriteLine(a+b+c);
    }
这样的话Add(1)的值就为7,Add(1,2)的值就为8,Add(1,2,3)就为9,Add(1,2,3,4)就为10,如果想不想按照顺序来可以使用命名参数,来改变任意参数如

    Add(1,d:4)
 这样就可以实现1+1+2+4而不用按照顺序来.命名参数就是直接在变量名后加冒号：就行,就可以准确定位.<br><br>
**:memo:个数可变的参数**<br>
使用可变参数就可以添加任意参数,需要关键字params,如下所示:

    public void AnyNumber(params int[] data)
    {
        foreach(var x in data)
        {
            Console.WriteLine(x);
        }
    }
AnyNumber的参数是类型是int[],可以传递一个int数组,并且没有长度限制,这里不是在参数直接传入一个数组,而是像数组一样给多个参数如:

    AnyNumber(1);
    AnyNumber(1,2,3,4);
这样就可以给这个数组赋值,根据参数个数来扩充数组大小.这里举个实例,在C语言里,如果想写一个输入任意数累加的函数就会存在着参数个数多少的问题,因为在C语言中,函数提供参数是有个数的,像C#下面这样:

     static void AnyNumber(params int[] data)
     {
         int sum = 0;
         foreach(var x in data)
         {
             sum+=x;            
         }
         Console.WriteLine(sum);
     }
这样就可以实现任意个参数相加的函数,如AnyNumber(1,2)就是1+2,AnyNumber(1,2,3)就是1+2+3.如果不这样就要用到前面所讲的重载,但这样如果参数过多,重载也就显得不方便.当然上面说的是同类型的参数,还可以添加不同的类型,这时候就要使用object数组：

    static void AnyNumber(params object[] data)
    {
        foreach(var x in data)
        {
            Console.WriteLine(x); 
        }
    }
这样你就可以加入不同的类型,像下面分别加入一个int,string,double类型,最后一个甚至还可以加入一个类:

    AnyNumber(1,"a",3.14,new Myclass());
当然也可以和已有参数一起使用如:

    static void AnyNumber(int a,params object[] data)
但是这样a就不属于data数组里面的类容了,它是独立于data数组外的一个参数.
***
## :book:1.4构造函数
声明基本构造函数的语言就是声明一个与包含的类同名字的方法,但该方法没有返回类型：

    public class Myclass
    {
        //与类名一样
        public Myclass()
        {
            //实现类容
        }
    }
如果没有提供任何构造函数,编译器会自动在后台生成一个默认的构造函数.但它只能完成基本的操作,给成员字段初始化为默认值,如果想更改其他的,需要自己写构造函数
相当于重载构造函数,但是提供带参的构造函数,编译器就不会自动生成构造函数.下面来表示一个坐标点的构造函数：

    //声明一个点的类
    class Point
    {
        private int x;
        private int y;
        public Point(int a,int b)
        {
            x = a;
            y = b;
        }
    }
    //在实例化时就可以传参
    var  p = new Point(1,2);
上面这种形式就可以完成实例化一个点(1,2).对于构造函数的修饰符如果不是公有或者受保护的构造函数,这就使Point不能在new 运算符下外部代码中实例化,但又可以编写静态属性或方法,这个在后面介绍.<br><br>
**:memo:从构造函数中调用其他构造函数**<br>
有时,在一个类中有几个构造函数,以容纳某些可选参数,这些构造函数包含一些共同的代码.例如以下情况:

    class Car
    {
        private string _description;
        private int _plateNumber;
        
        public Car(string des,int pla)
        {
            _description = des;
            _plateNumber = pla;
        }
        public Car(string des)
        {
            _description = des;
            _plateNumber = 555555;
        }
    }
这两个构造函数初始化相同的的字段,显然,最好把代码写在一个地方.C#有个特殊功能的语法,称为函数初始化器,可以实现此目的：

    class Car
    {
        private string _description;
        private int _plateNumber;
        
        public Car(string des,int pla)
        {
            _description = des;
            _plateNumber = pla;
        }
        public Car(string des) : this(des,555555){}
    }
这里,this关键字仅调用参数最匹配的那个构造函数.this(des,555555),实质上就是再一次调用构造函数Car,只不过之前先先调用自己这个构造函数.注意,构造函数初始化器在构造函数的函数体之前执行,假定运行下面的代码:

    var myCar = new Car("Ferrari");
在这个例子中只提供了一个参数所以就引用了第二个构造函数public Car(string des)让_description的值为"Ferrari",然后再调用this(des,555555)使得_plateNumber字段为默认值555555.如果你提供参数为2个,则构造函数就会调用第一个,直接跳过第二个构造函数从而取代默认值555555.<br><br>
**:memo:静态函数**<br>
C#的一个新特性是也可以给类编写无参数的静态构造函数.这种构造函数只执行一次,而前面的构造函数是实例化构造函数,只要创建类的对象,就会执行它：

    class MyClass
    {
        static MyClass()
        {
            Console.WriteLine("Hello World!");
        }
        static public void show()
        {
            Console.WriteLine("Hello");
        }
    }
接下来我们调用这个静态函数,如：

    var m = new MyClass();
直接运行就可以调用这个构造函数,如果是静态方法就需要直接调用类名：

    MyClass.show();
关于静态将专门做出一篇我自己的理解文章<br><br>
## :book:1.5只读成员
如果不希望在初始化后修改数据成员,就可以使用readonly关键字.下面详细描述只读字段和只读属性.
## :book:1.6只读字段
为了保证对象的字段不能改变,字段可以用readonly关键字,带有readonly只能在构造函数中分配值.使用只读字段作为类成员时,需要把static修饰符分配给该字段,下面举个例子,我们想记录注册的人数:

    class User
    {
        private string userName;
        private static readonly int userNumber = 0;
        //记录用户人数
        static User(string Name)
        {
            userName = Name;
            userNumber+=1;
        }
    }
#### 本章类容还在不断更新中......如有问题或者错误可以联系作者.  Email：724119519@qq.com :bowtie::bowtie::bowtie: ####
#### 最近更新时间：2018.8.27 21:16 ####
