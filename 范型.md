# :open_file_folder:泛型 #
## :file_folder:1.范型概述
### :blue_book:1.1性能
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从值类型转换为引用类型称为**装箱**>.如果方法需要把一个对象作为参数,同时转递一个值类型,装箱操作就会自动运行.另一方面,
装箱的值类型可以使用拆箱操作作转换为值类型.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面例子显示了System.Collections名称空间的ArrayList类.ArrayList储存对象,Add()方法定义为需要把一个对象作为参数.

```C#
	var list = new ArrayList();
	
	//装箱操作,并由值类型转化为引用类型.	
	list.Add(25);
	
	//拆箱操作,引用类型转化为值类型.
	int i1 = (int)list[0];
	
	foreach(int i2 in list)
	{
	    Console.WriteLine(i2);
	}
```
	装箱和拆箱操作很容易,但性能损失比较大,遍历许多项尤其如此
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;using System.Collections.Generic名称空间中的List<T>类不使用对象,而是在使用时定义类型.在下面的例子中,List<T>类的范型定义为int,所以int类型在编译器动态生成的类中使用,不再进行装箱和拆箱：

```C#
	var list = new List<int>();
	list.Add(44);
	int i1 = list[0];
	foreach(int i2 in list)
	{
	    Console.WriteLine(i2);
	}
```
因为List<T>类不使用对象,而是在使用时定义类型.所以在int类型下list.Add("abcdef")方法不能添加字符类型，list类只接受int型,添加其余类型编译器会报错.
*********
	
### :blue_book:1.2类型安全
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;范型的另一个特性是类型安全.与ArrayList类一样,如果使用对象,就可以在这个集合中添加任意类型.下面的例子在ArrayList类型的集合中添加3个不同类型

```C#
	var list = new ArrayList();
	list.Add(25);
	list.Add("abcd");
	//添加类,要有该类名
	list.Add(new MyClass());
	foreach (var item in list)
	{
	     Console.WriteLine(item);
             //如果是类会遍历显示是类名,如fanxing.MyClass
	}
```
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在范型类List<T>中,范型类型T定义了允许使用的类型,即T所表示的类型为唯一使用类型,其余类型加入会编译器错误

```C#
	//只允许T型加入(T代表各种类型如int,string,new class...)
	var list = new List<T>();
	
	//只允许int型加入
	var list = new List<int>();
	
	//只允许string型加入
	var list = new List<string>();
```
*****
### :blue_book:1.3二进制代码的重用
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;范型类可以定义一次,并且可以许多不同的类型实例化,例如System.Collections.Generic名称空间中的List<T>用一个int,string,new Class类型实例化：

```C#
	var list = new List<int>();
	list.Add(41);
	var stringList = new List<string>();
	stringList.Add("abcd");
	var myClassList = new List<MyClass>();
	myClassList.Add(new MyClass());
```
如果是类,如第三个中 new List<MyClass>();<T>中的T该为已有类名,表面只能引用这个类.
***
## :file_folder:2.创建范型类
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先先来创建一个非范型链表类,它可以包含各种对象,后面在转化成范型类.在链表中一个元素引用下一个元素.所以就必须创建一个类,它封装在链表中,并引用下一个对象.

#### 还在不停的更新中......如有问题或者错误可以联系作者, Email：724119519@qq.com :bowtie::bowtie::bowtie: ####
#### 最近更新时间：2018.8.26 22:40 ####
