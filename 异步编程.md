# :maple_leaf:异步编程

* 什么是异步？

异步处理不用阻塞当前线程来等待处理完成，而是允许后续操作，直至其它线程将处理完成，并回调通知此线程。

* 异步和多线程

相同点：避免调用线程阻塞，从而提高软件的可响应性。

* 不同点：

异步操作无须额外的线程负担，并且使用回调的方式进行处理，在设计良好的情况下，处理函数可以不必使用共享变量（即使无法完全不用，最起码可以减少 共享变量的数量），减少了死锁的可能。C#5.0 .NET4.5 以后关键字Async和Await的使用，使得异步编程变得异常简单。

多线程中的处理程序依然是顺序执行，但是多线程的缺点也同样明显，线程的使用（滥用）会给系统带来上下文切换的额外负担。并且线程间的共享变量可能造成死锁的出现。

******
 

  
## :four_leaf_clover:创建任务 ##

首先是异步所要使用的名称空间`using System.Threading.Tasks;`与`using System.Threading;`,首先是一个延时的方法：

```C#
        static int add(int a,int b){
            Console.WriteLine($"正在计算{a}+{b}......");
            Task.Delay(5000).Wait();
            return a+b;
        }
```
然后我们想在延时的时间继续执行其他的方法，这个时候就要引入异步编程：

```C#
        static Task<int> addAsync(int a,int b){  
        //lembda表达式
            return Task.Run<int>(()=>{
                return add(a,b);
            });
        }
```
Task<int>定义了一个返回int型的任务，一个简单的做法就是用 Task.Run方法返回一个任务。

## :four_leaf_clover:调用异步方法 ##

可以使用await关键字来调用返回任务的异步方法。使用await关键字需要有用async修饰符声明的方法。在异步方法完成前，该方法内部其他的代码不会执行。

```C#
        public async static void UseAddAsync(){
            int r2 = await addAsync(4,7);
            Console.WriteLine(r2); 
        }
```

## :four_leaf_clover:延续任务 ##

可以使用上面的方法调用异步，还可以使用不用async修饰符的延续任务的方法。

```C#
        public static void Continue(){
            Task<int> task = addAsync(3,5);
            task.ContinueWith(t=>{
                int a = t.Result;
                Console.WriteLine(a);
            });
        }
```

## :four_leaf_clover:多个异步方法的使用 ##

```C#
        public async static void UseAddAsync(){
            //顺序调用
           // int r = await addAsync(5,3);
           //int r2 = await addAsync(4,7);
            // Console.WriteLine(r2);
           
           //组合器使用
           Task<int> t1 = addAsync(3,5);
           Task<int> t2 = addAsync(4,5);
           await Task.WhenAll(t2,t1);
           
            Console.WriteLine(t1.Result+t2.Result);
            
            
          
       }
```

*********

## :four_leaf_clover:线程启动方式1-异步委托 ##

