# :maple_leaf:异步编程

* 什么是异步？

异步处理不用阻塞当前线程来等待处理完成，而是允许后续操作，直至其它线程将处理完成，并回调通知此线程。

* 异步和多线程

相同点：避免调用线程阻塞，从而提高软件的可响应性。

* 不同点：

异步操作无须额外的线程负担，并且使用回调的方式进行处理，在设计良好的情况下，处理函数可以不必使用共享变量（即使无法完全不用，最起码可以减少 共享变量的数量），减少了死锁的可能。C#5.0 .NET4.5 以后关键字Async和Await的使用，使得异步编程变得异常简单。

多线程中的处理程序依然是顺序执行，但是多线程的缺点也同样明显，线程的使用（滥用）会给系统带来上下文切换的额外负担。并且线程间的共享变量可能造成死锁的出现。

******
# :maple_leaf:异步方式开启之一异步委托

我们可以使用异步委托中的方法来开启新的线程，看下面这段示例:

```C#
        static void Fun1()
        {
            Console.WriteLine("Hello World!");
        }
        static void Fun2(int i)
        {
            Console.WriteLine($"i = {i}");
        }
        static void Main(string[] args)
        {            
            //定义委托
            Action a = Fun1;
            Action<int> b = Fun2;
            
            //开启一个新的线程来实现委托a方法
            a.BeginInvoke(null,null);
            b.BeginInvoke(5,null, null);
           
            Console.WriteLine("THE END?");
            Console.ReadKey();
        }
```
在控制台面板上我们可以看到"THE END?"并不是在控制台最后面输出，这是因为开启了新的线程(异步执行)所以出现的顺序并不一样，这些都是编译器自动分配的。
上面的委托是基于Action委托，对于Func委托上面的方式不能够返回结果值，需要如下的方法：

```C#
        static int Fun3(int i)
        {
            //Fun3延时2s
            Thread.Sleep(2000);
            return i * i;
        }
        static void Main(string[] args)
        {            
            Func<int, int> c = Fun3;
            //IAsyncResult获取线程状态
            IAsyncResult ar =  c.BeginInvoke(7,null, null);
            Console.WriteLine("THE END?");
            //如果线程没有执行完毕
            while (ar.IsCompleted==false)
            {
                Console.Write(".");
                Thread.Sleep(20);
            }
            //接受返回值
            int r = c.EndInvoke(ar);
            Console.WriteLine(r);
            Console.ReadKey();
        }
```

对于Func返回值的委托，它要在该委托方法执行完毕才会返回值，上面的例子Fun3延时2s，让程序处于等待时间，但是并不影响其他的线程，该线程结束后就会返回值，
返回值采用EndInvoke()方法。如果想对进程等待进行处理，可以采用IAsyncResult获取进程状态，其下的IsCompleted可以判断进程是否执行完毕，还可以采用AsyncWaitHandle.WaitOne()方法来判断线程是否结束，该方法返回一个bool类型，true代表线程结束，反之亦然。

```C#
        static int Fun3(int i)
        {
            Thread.Sleep(3000);
            return i * i;
        }
        static void Main(string[] args)
        {            
            Func<int, int> c = Fun3;
            IAsyncResult ar =  c.BeginInvoke(7,null, null);
            //线程等待
            bool isEnd = ar.AsyncWaitHandle.WaitOne(5000);
            if(isEnd)
            {
                int res = c.EndInvoke(ar);
                Console.WriteLine($"线程结束，结果为{res}");
            }
            else
            {
                Console.WriteLine("线程以请求超时");
            }
            Console.ReadKey();
        }
```
AsyncWaitHandle.WaitOne(5000)代表进程允许等待5s，如果程序在这个时间类结束返回true，如果超过这个时间，则会停止继续等待线程，并返回false。上面的委托
延时为3s但是我们等待5s，最后线程还是会运行3s结束，并不会真的等完5s，5s只是最长的等待时间。关于线程的结束，还可以采用回调方法，上面的BeginInvoke()方法中后两个参数null可以用来回调：

```C#
        static int Fun3(int i)
        {
            Thread.Sleep(3000);
            return i * i;
        }
        static void Main(string[] args)
        {            
            Func<int, int> c = Fun3;
            //引用回调方法 OnCallBack
            IAsyncResult ar =  c.BeginInvoke(7, OnCallBack, null);
            
            Console.ReadKey();
        }
        static void OnCallBack(IAsyncResult ar)
        {
            Console.WriteLine("线程回调");
        }

```
看上的例子把第一个null改为一个方法名，我们可以看到最后线程会调用该方法，所以倒数第二个参数其实就是一个回调方法，但是方法参数一定要有IAsyncResult参数的声明，不然会出现无法转换方法组的错误。对于返回值的提取，就需要使用最后一个参数：

```C#
        static int Fun3(int i)
        {
            Thread.Sleep(3000);
            return i * i;
        }
        static void Main(string[] args)
        {            
            Func<int, int> c = Fun3;
            //回调具有返回值的方法
            IAsyncResult ar =  c.BeginInvoke(7,OnCallBack, c);
            
            Console.ReadKey();
        }
        static void OnCallBack(IAsyncResult ar)
        {
            Console.WriteLine("线程回调");
            Func<int, int> a = ar.AsyncState as Func<int, int>;
            int res = a.EndInvoke(ar);
            Console.WriteLine($"线程结束，结果为{res}");
        }
```

与前面不一样的是把委托的返回值显示出来，这时需要在回调方法中 Func<int, int> a = ar.AsyncState as Func<int, int> 转换类型，再由c.BeginInvoke(7,OnCallBack, c)最后一个参数传递了委托c这样就可以实现了返回值的显示。BeginInvoke()方法的后两位参数，即是回调方法与回调委托变量。当然上面也可以使用lambda表达式更为简单：

```C#
     c.BeginInvoke(7, ar =>
     {
         int res = c.EndInvoke(ar);
         Console.WriteLine($"线程结束，结果为{res}");
     },null);
```

## :four_leaf_clover:创建任务 ##

首先是异步所要使用的名称空间`using System.Threading.Tasks;`与`using System.Threading;`,首先是一个延时的方法：

```C#
        static int add(int a,int b){
            Console.WriteLine($"正在计算{a}+{b}......");
            Task.Delay(5000).Wait();
            return a+b;
        }
```
然后我们想在延时的时间继续执行其他的方法，这个时候就要引入异步编程：

```C#
        static Task<int> addAsync(int a,int b){  
        //lembda表达式
            return Task.Run<int>(()=>{
                return add(a,b);
            });
        }
```
Task<int>定义了一个返回int型的任务，一个简单的做法就是用 Task.Run方法返回一个任务。

## :four_leaf_clover:调用异步方法 ##

可以使用await关键字来调用返回任务的异步方法。使用await关键字需要有用async修饰符声明的方法。在异步方法完成前，该方法内部其他的代码不会执行。

```C#
        public async static void UseAddAsync(){
            int r2 = await addAsync(4,7);
            Console.WriteLine(r2); 
        }
```

## :four_leaf_clover:延续任务 ##

可以使用上面的方法调用异步，还可以使用不用async修饰符的延续任务的方法。

```C#
        public static void Continue(){
            Task<int> task = addAsync(3,5);
            task.ContinueWith(t=>{
                int a = t.Result;
                Console.WriteLine(a);
            });
        }
```

## :four_leaf_clover:多个异步方法的使用 ##

```C#
        public async static void UseAddAsync(){
            //顺序调用
           // int r = await addAsync(5,3);
           //int r2 = await addAsync(4,7);
            // Console.WriteLine(r2);
           
           //组合器使用
           Task<int> t1 = addAsync(3,5);
           Task<int> t2 = addAsync(4,5);
           await Task.WhenAll(t2,t1);
           
            Console.WriteLine(t1.Result+t2.Result);
            
            
          
       }
```

*********

## :four_leaf_clover:线程启动方式1-异步委托 ##

